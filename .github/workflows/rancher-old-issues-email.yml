name: "Email old Rancher issues (auth/rbac/projects/audit)"

on:
  schedule:
    # Mondays and Thursdays at 09:00 UTC (adjust as desired)
    - cron: "0 9 * * 1,4"
  workflow_dispatch: {}

permissions:
  contents: write
  actions: read

jobs:
  send:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure seen list exists
        run: |
          mkdir -p .state
          touch .state/seen-issues.txt

      - name: Query issues and build email body (max 10, no repeats)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # NOTE: Do NOT use `sort:created-asc` here.
          # GitHub's GraphQL search often returns 0 results when `sort:` is present.
          QUERY='repo:rancher/rancher is:issue is:open (auth OR authentication OR login OR signin OR "sign in" OR "sign-in" OR logout OR session OR token OR jwt OR "access token" OR "refresh token" OR cookie OR csrf OR sso OR "single sign-on" OR saml OR oidc OR oauth OR oauth2 OR openid OR "openid connect" OR "open id" OR ldap OR ad OR "active directory" OR "azure ad" OR azuread OR okta OR keycloak OR dex OR "auth provider" OR "github auth" OR "gitlab auth" OR "google auth" OR "azure auth" OR "bitbucket auth" OR rbac OR permission OR permissions OR authorize OR authorization OR "access control" OR "global role" OR globalrole OR "global role binding" OR "role binding" OR rolebinding OR clusterrolebinding OR clusterrole OR "cluster role" OR "project role" OR "cluster member" OR "project member" OR "role template" OR roletemplate OR roletemplatebinding OR prtb OR crtb OR projectroletemplatebinding OR clusterroletemplatebinding OR subjectaccessreview OR sar OR impersonate OR impersonation OR project OR projects OR "project id" OR namespace OR namespaces OR "move namespace" OR "namespace move" OR "resource quota" OR limitrange OR "cluster scope" OR "project scope" OR audit OR auditing OR "audit log" OR "audit logs" OR auditlogging OR "audit logging" OR webhook OR "audit webhook" OR "audit sink" OR "apiserver audit" OR "kube-apiserver audit" OR fluentbit OR "fluent bit" OR "log forwarding" OR "log forwarder" OR "log shipper")'
          echo "Running search: $QUERY"

          echo "=== DEBUG: smoke test search (should be >0) ==="
          gh api graphql -f query='
            query($q: String!) {
              search(query: $q, type: ISSUE, first: 1) {
                issueCount
                nodes { ... on Issue { number url } }
              }
            }' -f q='repo:rancher/rancher is:issue is:open project' | jq

          PER_PAGE=100
          MAX_PAGES=20  # 20*100 = 2000 attempted (GitHub search may effectively cap around 1000)

          echo '[]' > all.json

          after_cursor=""
          page=1
          while [ "$page" -le "$MAX_PAGES" ]; do
            echo "Fetching page $page / $MAX_PAGES (after_cursor=${after_cursor:-<none>})"

            if [ -z "$after_cursor" ]; then
              gh api graphql -f query='
                query($q: String!, $n: Int!) {
                  search(query: $q, type: ISSUE, first: $n) {
                    pageInfo { hasNextPage endCursor }
                    nodes {
                      ... on Issue {
                        number
                        title
                        url
                        createdAt
                        updatedAt
                        author { login }
                        labels(first: 50) { nodes { name } }
                      }
                    }
                  }
                }' -f q="$QUERY" -F n="$PER_PAGE" > page.json
            else
              gh api graphql -f query='
                query($q: String!, $n: Int!, $after: String) {
                  search(query: $q, type: ISSUE, first: $n, after: $after) {
                    pageInfo { hasNextPage endCursor }
                    nodes {
                      ... on Issue {
                        number
                        title
                        url
                        createdAt
                        updatedAt
                        author { login }
                        labels(first: 50) { nodes { name } }
                      }
                    }
                  }
                }' -f q="$QUERY" -F n="$PER_PAGE" -f after="$after_cursor" > page.json
            fi

            fetched=$(jq '.data.search.nodes | length' page.json)
            has_next=$(jq -r '.data.search.pageInfo.hasNextPage' page.json)
            end_cursor=$(jq -r '.data.search.pageInfo.endCursor' page.json)

            echo "Fetched nodes this page: $fetched"

            # Append nodes into all.json
            jq -s '.[0] + (.[1].data.search.nodes // [])' all.json page.json > all.tmp.json
            mv all.tmp.json all.json

            if [ "$has_next" != "true" ]; then
              echo "No next page. Stopping pagination."
              break
            fi

            after_cursor="$end_cursor"
            page=$((page + 1))
          done

          echo "=== DEBUG: total fetched nodes (all pages combined) ==="
          jq 'length' all.json

          echo "=== DEBUG: all.json first node sample ==="
          jq '
            .[0]
            | {
                number,
                url,
                createdAt,
                updatedAt,
                labelCount: ((.labels.nodes // []) | length),
                labels: ((.labels.nodes // []) | map(.name))
              }
          ' all.json

          echo "=== DEBUG: all.json count with NO team/* label (pre-seen) ==="
          jq '
            map(select(([(.labels.nodes // [])[].name] | map(ascii_downcase) | any(startswith("team/"))) | not))
            | length
          ' all.json

          echo "=== DEBUG: all.json contains issue #40482? ==="
          jq '
            map(select(.number == 40482))
            | length
          ' all.json

          # Seen list as JSON array
          SEEN_JSON=$(awk 'NF {print}' .state/seen-issues.txt | jq -R -s 'split("\n") | map(select(length>0))')
          echo "Seen list count: $(echo "$SEEN_JSON" | jq 'length')"

          # Final selection
          jq --argjson seen "$SEEN_JSON" '
            . |
            # Exclude any issue with any label starting with "team/" (case-insensitive)
            map(select(([(.labels.nodes // [])[].name] | map(ascii_downcase) | any(startswith("team/")) | not))) |
            # Exclude issues already emailed
            map(select(.url as $u | ($seen | index($u)) == null)) |
            # Oldest first (within what we fetched)
            sort_by(.createdAt) |
            # Limit to 10
            .[0:10]
          ' all.json > issues-to-email.json

          COUNT=$(jq 'length' issues-to-email.json)
          echo "New issues to email (max 10): $COUNT"

          echo "Sample candidates (first 10):"
          jq -r '.[] | "\(.createdAt) \(.url) labels=" + ([(.labels.nodes // [])[].name] | join(","))' issues-to-email.json

          echo "EMAIL_SUBJECT=Rancher old open issues (auth/RBAC/projects/audit) - $(date -u +%Y-%m-%d)" >> $GITHUB_ENV

          {
            echo "# rancher/rancher: Old open issues for auth/RBAC/projects/audit (no team/* labels)"
            echo
            echo "Generated: $(date -u +"%Y-%m-%d %H:%M UTC")"
            echo
            if [ "$COUNT" -eq 0 ]; then
              echo "_No new matching issues found._"
            else
              echo "## Oldest first (up to 10, never repeated)"
              echo
              jq -r '
                .[] |
                "- [#\(.number)](\(.url)) \(.title)\n  - created: \(.createdAt)\n  - updated: \(.updatedAt)\n  - author: \(.author.login // "unknown")\n  - labels: " + ([(.labels.nodes // [])[].name] | join(", "))
              ' issues-to-email.json
            fi
          } > email.md

          # Update seen list if we actually emailed issues
          if [ "$COUNT" -gt 0 ]; then
            jq -r '.[].url' issues-to-email.json >> .state/seen-issues.txt
            sort -u .state/seen-issues.txt -o .state/seen-issues.txt
          fi

      - name: Send email
        uses: dawidd6/action-send-mail@v4
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ env.EMAIL_SUBJECT }}
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.EMAIL_FROM }}
          secure: true
          content_type: text/markdown
          body: file://email.md

      - name: Commit updated seen list (if changed)
        run: |
          if git diff --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .state/seen-issues.txt
          git commit -m "chore: update seen issues list"
          git push
