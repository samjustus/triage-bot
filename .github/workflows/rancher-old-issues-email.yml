name: "Email old Rancher issues (auth/rbac/projects/audit)"

on:
  schedule:
    # Mondays and Thursdays at 09:00 UTC (adjust as desired)
    - cron: "0 9 * * 1,4"
  workflow_dispatch: {}

permissions:
  contents: write  # needed to commit the seen-issues file
  actions: read

jobs:
  send:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure seen list exists
        run: |
          mkdir -p .state
          touch .state/seen-issues.txt

      - name: Query issues and build email body (max 10, no repeats)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Expanded keyword set for auth/RBAC/projects/audit in Rancher/K8s
          QUERY='repo:rancher/rancher is:issue is:open sort:created-asc (auth OR authentication OR login OR signin OR "sign in" OR "sign-in" OR logout OR session OR token OR jwt OR "access token" OR "refresh token" OR cookie OR csrf OR sso OR "single sign-on" OR saml OR oidc OR oauth OR oauth2 OR openid OR "openid connect" OR "open id" OR ldap OR ad OR "active directory" OR "azure ad" OR azuread OR okta OR keycloak OR dex OR "auth provider" OR "github auth" OR "gitlab auth" OR "google auth" OR "azure auth" OR "bitbucket auth" OR rbac OR permission OR permissions OR authorize OR authorization OR "access control" OR "global role" OR globalrole OR "global role binding" OR "role binding" OR rolebinding OR clusterrolebinding OR clusterrole OR "cluster role" OR "project role" OR "cluster member" OR "project member" OR "role template" OR roletemplate OR roletemplatebinding OR prtb OR crtb OR projectroletemplatebinding OR clusterroletemplatebinding OR subjectaccessreview OR sar OR impersonate OR impersonation OR project OR projects OR "project id" OR namespace OR namespaces OR "move namespace" OR "namespace move" OR "resource quota" OR limitrange OR "cluster scope" OR "project scope" OR audit OR auditing OR "audit log" OR "audit logs" OR auditlogging OR "audit logging" OR webhook OR "audit webhook" OR "audit sink" OR "apiserver audit" OR "kube-apiserver audit" OR fluentbit OR "fluent bit" OR "log forwarding" OR "log forwarder" OR "log shipper")'

          echo "Running search: $QUERY"

          # NOTE:
          # - GitHub "search" has practical caps (commonly 1000 results addressable).
          # - So "fetch 2000" is implemented as 20 pages x 100, but you may not actually
          #   get 2000 distinct results depending on GitHub search limits.
          PER_PAGE=100
          MAX_PAGES=20

          # Initial empty combined array
          echo '[]' > all.json

          after_cursor=""
          page=1
          while [ "$page" -le "$MAX_PAGES" ]; do
            echo "Fetching page $page / $MAX_PAGES (after_cursor=${after_cursor:-<none>})"

            if [ -z "$after_cursor" ]; then
              gh api graphql -f query='
                query($q: String!, $n: Int!) {
                  search(query: $q, type: ISSUE, first: $n) {
                    pageInfo { hasNextPage endCursor }
                    nodes {
                      ... on Issue {
                        number
                        title
                        url
                        createdAt
                        updatedAt
                        author { login }
                        labels(first: 50) { nodes { name } }
                      }
                    }
                  }
                }' -f q="$QUERY" -F n="$PER_PAGE" > page.json
            else
              gh api graphql -f query='
                query($q: String!, $n: Int!, $after: String) {
                  search(query: $q, type: ISSUE, first: $n, after: $after) {
                    pageInfo { hasNextPage endCursor }
                    nodes {
                      ... on Issue {
                        number
                        title
                        url
                        createdAt
                        updatedAt
                        author { login }
                        labels(first: 50) { nodes { name } }
                      }
                    }
                  }
                }' -f q="$QUERY" -F n="$PER_PAGE" -f after="$after_cursor" > page.json
            fi

            fetched=$(jq '.data.search.nodes | length' page.json)
            has_next=$(jq -r '.data.search.pageInfo.hasNextPage' page.json)
            end_cursor=$(jq -r '.data.search.pageInfo.endCursor' page.json)

            echo "Fetched nodes this page: $fetched"

            # Append nodes into all.json
            jq -s '.[0] + (.[1].data.search.nodes // [])' all.json page.json > all.tmp.json
            mv all.tmp.json all.json

            if [ "$has_next" != "true" ]; then
              echo "No next page. Stopping pagination."
              break
            fi

            after_cursor="$end_cursor"
            page=$((page + 1))
          done

          echo "=== DEBUG: total fetched nodes (all pages combined) ==="
          jq 'length' all.json

          # --- DEBUG CHECKS (combined all pages) ---
          echo "=== DEBUG: all.json first node sample ==="
          jq '
            .[0]
            | {
                number,
                url,
                createdAt,
                updatedAt,
                labelCount: ((.labels.nodes // []) | length),
                labels: ((.labels.nodes // []) | map(.name))
              }
          ' all.json

          echo "=== DEBUG: all.json count with NO team/* label (pre-seen) ==="
          jq '
            map(select(([(.labels.nodes // [])[].name] | map(ascii_downcase) | any(startswith("team/"))) | not))
            | length
          ' all.json

          echo "=== DEBUG: all.json contains issue #40482? ==="
          jq '
            map(select(.number == 40482))
            | length
          ' all.json
          # --- END DEBUG CHECKS ---

          # Read seen URLs into a JSON array for jq
          SEEN_JSON=$(awk 'NF {print}' .state/seen-issues.txt | jq -R -s 'split("\n") | map(select(length>0))')

          # Final selection
          jq --argjson seen "$SEEN_JSON" '
            . |
            # Exclude any issue with any label starting with "team/" (case-insensitive)
            map(select(([(.labels.nodes // [])[].name] | map(ascii_downcase) | any(startswith("team/")) | not))) |
            # Exclude issues already emailed
            map(select(.url as $u | ($seen | index($u)) == null)) |
            # Oldest first
            sort_by(.createdAt) |
            # Limit to 10
            .[0:10]
          ' all.json > issues-to-email.json

          COUNT=$(jq 'length' issues-to-email.json)
          echo "New issues to email (max 10): $COUNT"

          echo "Seen list count:"
          awk 'NF{c++} END{print c+0}' .state/seen-issues.txt

          echo "Sample candidates (first 10):"
          jq -r '.[] | "\(.createdAt) \(.url) labels=" + ([(.labels.nodes // [])[].name] | join(","))' issues-to-email.json

          echo "EMAIL_SUBJECT=Rancher old open issues (auth/RBAC/projects/audit) - $(date -u +%Y-%m-%d)" >> $GITHUB_ENV

          {
            echo "# rancher/rancher: Old open issues for auth/RBAC/projects/audit (no team/* labels)"
            echo
            echo "Generated: $(date -u +"%Y-%m-%d %H:%M UTC")"
            echo
            if [ "$COUNT" -eq 0 ]; then
              echo "_No new matching issues (all candidates already emailed, or none found)._"
            else
              echo "## Oldest first (up to 10, never repeated)"
              echo
              jq -r '
                .[] |
                "- [#\(.number)](\(.url)) \(.title)\n  - created: \(.createdAt)\n  - updated: \(.updatedAt)\n  - author: \(.author.login // "unknown")\n  - labels: " + ([(.labels.nodes // [])[].name] | join(", "))
              ' issues-to-email.json
            fi
          } > email.md

          # If we have issues, append their URLs to the seen list
          if [ "$COUNT" -gt 0 ]; then
            jq -r '.[].url' issues-to-email.json >> .state/seen-issues.txt
            sort -u .state/seen-issues.txt -o .state/seen-issues.txt
          fi

      - name: Send email
        uses: dawidd6/action-send-mail@v4
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ env.EMAIL_SUBJECT }}
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.EMAIL_FROM }}
          secure: true
          content_type: text/markdown
          body: file://email.md

      - name: Commit updated seen list (if changed)
        run: |
          if git diff --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .state/seen-issues.txt
          git commit -m "chore: update seen issues list"
          git push
